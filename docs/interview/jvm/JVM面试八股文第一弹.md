# JVM面试八股文第一弹

**推荐阅读：**

- **[面试手册第三版，更新！](http://mp.weixin.qq.com/s?__biz=MzA4NjU1MzA2MQ==&mid=2647725969&idx=1&sn=4a4c8fc630e366d6497b42a5d600f71b&chksm=87e34f1bb094c60ddde4fd3ab10a6fe2145d826a82d67cc8356866615735465ec11a35101921&scene=21#wechat_redirect)
  **
- [面试八股文系列](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzA4NjU1MzA2MQ==&action=getalbum&album_id=1966226418825035778#wechat_redirect)
- [程序人生系列](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzA4NjU1MzA2MQ==&action=getalbum&album_id=1816486914183512067#wechat_redirect)
- [大厂面经系列](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzA4NjU1MzA2MQ==&action=getalbum&album_id=2105056235833131010#wechat_redirect)

**文章目录**

- Java内存区域

- - JVM的主要组成部分及作用
  - JVM运行时数据区域

- 关于HotSpot虚拟机对象问题

- - 对象是如何创建的
  - 创建对象时内存是如何分配的
  - 如何处理并发安全问题
  - 对象的内存布局
  - 对象的访问方式有哪些

- 内存溢出异常问题

- - Java内存泄漏和内存溢出是什么，如何避免
  - 什么情况会发生栈内存溢出



# JVM面试八股文

> 这里先简单解释下JVM（Java虚拟机）的作用，一般C或者C++都是直接将代码生成机器指令，CPU可以直接执行这些指令，而Java则需要先生成字节码，JVM再将字节码解释成机器码。这么做的好处就是JVM屏蔽了底层平台的差别，可以做到一次编译，在各个平台运行，比如在Windows编译，也可以在Linux运行，这么做的缺点是JVM会影响性能，这也是Java的性能一般不如C或C++的原因。

## Java内存区域

### JVM的主要组成部分及作用

> 面试中的高频面试题，需要背下来

JVM主要由**类装载系统**、**执行引擎**、**运行时数据区**、**本地接口**等四部分组成，其中**运行时数据区**是重点掌握内容，如下图

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/cBnxLn7axrxjTWfeBYGlL9DeiaOdH9VeHJKhpcjlahDzDHARoLTv5uNc0ic8yiaSOeS6DkIb71Bk1eibiccL1nBAAbA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

- 类装载子系统（类加载器）：加载类文件到内存
- 执行引擎：也成为解释器，负责解释指令，交由操作系统执行
- 本地库接口：与其他语言交互时所使用的
- 运行时数据区：JVM的内存区域

工作原理：首先通过编译器把 Java 代码转换成字节码，类加载器（ClassLoader）再把字节码加载到内存中，将其放在运行时数据区（Runtime data area）的方法区内，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。

### JVM运行时数据区域

JVM的运行时数据区主要由**方法区、堆、虚拟机栈、本地方法栈、程序计数器**组成，其中方法区和堆是**线程共享数据区**，虚拟机栈、本地方法栈、程序计数器是**线程私有数据区**，结构见上图。

- 程序计数器：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成，并且程序计数器是唯一一个不会出现 `OutOfMemoryError` 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。
- 虚拟机栈：虚拟机栈描述的是**Java方法**执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至完成的过程中，都会对应着一个栈帧在虚拟机栈中入栈到出栈的过程
- 本地方法栈：本地方法栈与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的，并且与虚拟机栈一样，也会抛出`StackOverflowError`和`OutOfMemoryError`
- 堆：Java 虚拟机中内存最大的一块，几乎所有的对象实例都在这里分配内存
- 方法区：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据

## 关于HotSpot虚拟机对象问题

> HotSpot虚拟机是Sun JDK和OpenJDK中所带的虚拟机，也是目前使用范围最广的Java虚拟机。下面会以HotSpot虚拟机为背景了解下Java堆中对象的分配、布局和访问的过程

### 对象是如何创建的

对象的创建过程主要有以下几个过程

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/cBnxLn7axrxjTWfeBYGlL9DeiaOdH9VeHJnvTDK3icUjbKF0m3zRlJpF0pBIt8ELknkUJVIiaJdBEZBpecTX6rvUA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

1. 类加载检查：虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。
2. 分配内存：在类加载检查后，就要为新生对象分配内存了，对象内存所需大小在类加载完成后便可以确定，内存分配方式根据Java堆中内存是否完整主要分为**指针碰撞**和**空闲列表**两种。
3. 初始化零值：内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这也是为什么字段在Java代码中可以不赋值就能直接使用的原因。
4. 设置对象头：初始化零值后，虚拟机需要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息都是存放在对象的对象头中。根据虚拟机当前的运行状态不同，如是否使用偏向锁等，对象头都会有不同的设置方式。
5. 执行init方法：上述操作完成后，从虚拟机的角度看，一个新的对象已经产生了。但从Java程序的角度看，对象创建才刚刚开始，`<init>`方法还没有执行，所有的字段都还为零。所以，一般执行完`new`指令后还会接着执行`<init>`方法，把对象按照程序员的意愿进行初始化（赋值），这样一个真正可用的对象才算生产出来

### 创建对象时内存是如何分配的

上文提到，创建对象的内存分配方式会根据Java内存是否完整分为**指针碰撞（完整）**和**空闲列表（不完整）**两种：

- 指针碰撞：假设为Java堆中内存是绝对完整的，所有用过的内存放到一边，空闲的内存放到另一边，中间放着一个指针作为分界点的指示器，所分配的内存就是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为指针碰撞。
- 空闲列表：假设Java堆中的内存并不是完整的，已使用的内存和空闲内存都混在一起了，这时虚拟机需要维护一个列表，用来记录哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为空闲列表。

注：选择哪种分配方式由Java堆是否完整决定，Java堆是否完整由所采用的垃圾收集器是否带有压缩整理功能决定。因此，在使用Serial、ParNew等垃圾收集器时系统采用的是指针碰撞，在使用CMS等基于标记擦除算法的收集器时，采用的是空闲列表。

### 如何处理并发安全问题

在创建对象时还需要保证线程安全，因为对象创建在虚拟机中是非常频繁的，即使仅仅修改了一个指针所指向的位置，在并发场景下也不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决方案有以下两种：

- 采用CAS加上失败重试的方式保证更新操作的原子性（CAS有在Java并发编程中提到，可以看看之前的文章）
- 每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB），哪个线程需要分配内存就在哪个线程的TLAB上分配，只有TLAB用完或对象大于TLAB中的剩余内存时，才需要采用CAS的方案

### 对象的内存布局

在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：**对象头**、**实例数据**和**对齐填充**

#### 对象头

对象头包含两部分信息，一部分用于存储自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

#### 实例数据

实例数据部分是对象真正存储的有效信息，也是代码中所定义的各种类型的字段内容

#### 对齐填充

HotSpot虚拟机的自动内存管理系统要求对象起止地址必须是8字节的整数倍，也就是说对象的大小必须是8字节的整数倍，对象头部分正好是8字节的整数倍，所以，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全，对齐填充并不是必然存在的，也没有特殊的含义，只是起到了占位符的作用。

### 对象的访问方式有哪些

建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。目前主流的访问方式有**使用句柄**和**直接指针**两种。

#### 句柄

Java堆中会划分出一块内存来作为句柄，reference中存储的是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息，如下图（图片来源于《深入理解Java虚拟机》）

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/cBnxLn7axrxjTWfeBYGlL9DeiaOdH9VeHF2C37YR2x6WJfh0d0U7P7I27czUmZnFZ3kyNttCaYRBTBvb4V5xfDQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

使用句柄访问对象的优势：reference中存储的是稳定的句柄地址，在对象移动时（垃圾回收时会经常移动对象）只会改变句柄中的实例数据指针，无需改变reference

#### 直接指针

如果使用直接指针访问，reference中存储的就是对象地址，而Java堆对象的布局需要考虑如何放置访问类型数据的相关信息，如下图（图片来源于《深入理解Java虚拟机》）

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/cBnxLn7axrxjTWfeBYGlL9DeiaOdH9VeH9Ykf5XvCq4XJGiaqpYibsltOGklI0FxLgz2VDZIIDt05MkLaTrl1kdNQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

使用直接指针访问对象的优势是省了一次指针定位的时间开销，速度更快

## 内存溢出异常问题

### Java内存泄漏和内存溢出是什么，如何避免

**内存泄漏**：指程序中动态分配给内存一些临时对象，并且这些对象始终没有被回收，一直占用着内存，简单来说就是申请内存使用完了不进行释放

常见的内存泄漏产生原因：

- **静态集合类引起内存泄漏**，因为静态集合的生命周期和JVM一致，所以静态集合引用的对象不能被释放
- **单例模式导致内存泄漏**，因为单例模式的静态特性，它的生命周期和JVM的生命周期一致，如果单例对象持有外部对象的引用，这个对象也不会被回收
- **内部类的对象被长期持有**，那么内部类对象所属的外部类对象也不能被收回
- **数据库连接、网络连接等各种连接没有显示释放导致内存泄漏**，例如在数据库连接后不再使用时，必须调用close方法释放与数据库的连接，否则会造成大量对象无法被回收进而造成内存泄漏
- **改变哈希值**，例如在一个对象存储到HashSet后，改变了对象中参与计算哈希值的字段，那么会导致对象的哈希值发生变化，和之前存入HashSet的哈希值不同，也就无法通过当前对象的引用在HashSet中找到这个对象，无法从HashSet中删除对象，造成内存泄漏，这也是为什么通常利用String类型的变量当作HashMap的key，因为String类型是不可变的

内存泄漏解决方案：写代码时尽量避免上述会造成内存泄漏的情况

**内存溢出**：指程序运行过程中无法申请到足够的内存导致的错误

常见的造成内存溢出的原因：

- 内存加载的数据量太大，内存不够用了
- 代码中存在死循环或循环产生大量对象
- 启动参数内存值设置过小
- 长期的内存泄漏也会导致内存溢出

内存溢出解决方案：

- 修改JVM启动参数，增加内存
- 使用内存查看工具动态查看内存使用情况
- 对代码进行排查，重点排查有没有上述提到的造成常见内存溢出情景的代码

### 什么情况会发生栈内存溢出

当线程所请求的栈深度超过虚拟机所允许的最大深度后，会发生栈溢出，即**StackOverflowError** ，比如在方法递归调用时就可能发生栈内存溢出，可以通过 JVM参数 -Xss 来调整栈内存的大小来避免栈内存溢出，但如果是代码问题光调整栈内存大小肯定是不够的，还是要从根本解决问题。

**参考：** 《深入理解Java虚拟机》