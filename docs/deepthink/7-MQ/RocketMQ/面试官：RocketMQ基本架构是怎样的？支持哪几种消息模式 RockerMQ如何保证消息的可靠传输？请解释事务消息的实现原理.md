# 面试官：RocketMQ基本架构是怎样的？支持哪几种消息模式? RockerMQ如何保证消息的可靠传输？请解释事务消息的实现原理

面试题概览：

- RocketMQ的基本架构是怎样的？请简述各组件的作用。
- RocketMQ支持哪几种消息模式（如点对点、发布/订阅）？请简要说明它们的区别。
- 如何使用Java客户端实现一个简单的消息生产者和消费者？
- RocketMQ如何保证消息的可靠传输？
- 在RocketMQ中，如何实现消息的顺序消费？遇到分区顺序消息和全局顺序消息时有何不同处理方式？
- RocketMQ如何实现高可用性？
- 谈谈RocketMQ的Consumer端是如何实现负载均衡的？如果Consumer组内新增或减少成员，RocketMQ如何调整？
- RocketMQ支持哪些消息重试策略？在什么情况下会触发消息重试？
- RocketMQ是如何存储消息的？
- 谈谈有哪些提高RocketMQ吞吐量和降低延迟的方法。
- 在RocketMQ集群中，如何进行消息的过期删除和磁盘空间管理？
- 解释事务消息的实现原理，并描述其在RocketMQ中的应用场景。
- 什么是RocketMQ中的死信队列？它是如何产生的？如何处理死信消息？
- RocketMQ支持哪些消息过滤方式？
- 如何监控RocketMQ集群的健康状态？有哪些常用的监控指标？
- 假设你遇到RocketMQ消息丢失的情况，你会从哪些方面进行排查？
- 设计一个场景，说明如何利用RocketMQ实现系统解耦和异步处理。



***\*面试官：RocketMQ的基本架构是怎样的？请简述各组件的作用。\****

Apache RocketMQ的基本架构包含以下几个核心组件，每个组件都扮演着特定的角色以确保消息的高效、可靠传递：

![图片](https://mmbiz.qpic.cn/mmbiz_png/B220micXXwOMMiaGkVpqqanDqlYXiaQIeGD7kkaJPLCjUqIyURib50e5gPOqicJUnXpt8OUFppCDbzHibI8vhF9lsDUw/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**1. NameServer：**

- 作用：NameServer是RocketMQ的命名服务和配置中心，它维护了整个集群的路由信息，包括Broker的地址、Topic与Queue的路由关系等。Producer和Consumer在初始化时会连接到NameServer集群获取Broker的信息，从而知道向哪个Broker发送消息或者从哪个Broker拉取消息。NameServer之间不进行数据同步，每个NameServer都是独立的，Producer和Consumer通常会连接多个NameServer以提高可用性。

**2. Broker：**

- 作用：Broker是RocketMQ的消息存储和转发的主体，负责接收来自Producer的消息并存储，同时为Consumer提供消息拉取服务。Broker分为Master和Slave两种角色，Master负责读写操作，Slave则作为Master的备份，用于故障切换以提高系统的高可用性。Broker还负责消息的持久化存储、消息刷盘策略、消息队列的分配与管理等。

**3. Producer：**

- 作用：Producer是消息的生产者，负责生成并将业务系统产生的消息发送到Broker。Producer支持多种发送模式，包括**同步发送、异步发送和单向发送**，以满足不同的业务需求，如可靠性、吞吐量的权衡。

**4. Consumer：**

- 作用：Consumer是消息的消费者，负责从Broker拉取消息并进行业务逻辑处理。RocketMQ支持广播消费和集群消费两种模式。广播消费下，一条消息会被所有Consumer实例消费；而在集群消费模式下，消息只会被Consumer Group内的一个或者多个Consumer实例（根据负载均衡策略）公平地消费。Consumer还支持自动负载均衡、消息过滤等功能。



此外，RocketMQ还涉及其他组件，例如：

- **Filter Server**（可选）：提供消息过滤功能，可以基于消息属性或内容进行过滤，减少不必要的消息传输，提高消费效率。
- **Dashboard**（可视化监控界面）：用于监控RocketMQ集群的运行状态，包括Broker的健康状况、消息堆积情况等，便于运维管理。





**面试官：RocketMQ支持哪几种消息模式（如点对点、发布/订阅）？请简要说明它们的区别。**

RocketMQ支持多种消息模式，每种模式适用于不同的业务场景，以下是几种主要的消息模式及其特点：

1. **发布/订阅模式**（Pub/Sub）：在这种模式下，消息生产者（Producer）发布消息到一个主题（Topic），所有订阅了该主题的消费者（Consumer）都能收到消息。这是典型的广播模式，适用于需要将信息广泛分发给多个接收者的场景。消息的复制和分发由RocketMQ自动处理，简化了消息的广播过程，但可能会导致消息重复消费和资源消耗较高。

   ![图片](https://mmbiz.qpic.cn/mmbiz_png/B220micXXwOMMiaGkVpqqanDqlYXiaQIeGDVwx3ehiciaklP3oRbB9USv8wQuaTwiccGn8KLzSy6OWOy8HoXnfnx7L8A/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

   

2. **集群消费模式**：在集群消费模式下，属于同一个消费者组（Consumer Group）的所有消费者会共同消费一个主题下的消息，但每条消息只会被组内的一个消费者消费。这种模式实现了消息在消费者组内的负载均衡，适合需要确保消息被处理且避免重复处理的场景。

   ![图片](https://mmbiz.qpic.cn/mmbiz_png/B220micXXwOMMiaGkVpqqanDqlYXiaQIeGDc2jhVM7sYO9gUBfdtmNVqk9XibpdlfYTuOEuicTyPEv36ZOtC0fe7M3w/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

3. **广播消费模式**：广播模式下，主题中的每条消息都会被消费者组中的每一个消费者实例接收并处理。即使多个消费者实例订阅了同一个主题，每条消息也会被每个实例独立消费一次，适用于需要所有订阅者都必须接收到消息的场景，比如系统通知或配置更新。

   ![图片](https://mmbiz.qpic.cn/mmbiz_png/B220micXXwOMMiaGkVpqqanDqlYXiaQIeGDLfUVwD4IeybMSXgTmd5kM5ZqpZ0MOyux0HuOnFlcyhx6Q1k3Hiaxb4w/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

4. **顺序消息**：顺序消息保证同一主题下的消息按照发送顺序进行消费，特别适合那些对消息处理顺序有严格要求的场景，比如交易系统中的订单处理。RocketMQ支持全局顺序消息和分区顺序消息，前者要求整个主题的消息有序，后者则是在每个消息队列内部保持消息顺序。

5. **事务消息**：事务消息用于实现分布式事务，确保消息生产和本地事务操作的原子性。它包含两阶段提交过程，确保消息要么都成功要么都不成功，适用于涉及跨服务的事务处理场景。

6. **延迟消息**：允许消息在指定的延迟时间后才被消费者消费，适用于如定时任务、消息的有效期控制等场景。

7. **批量消息**：生产者可以一次性发送一组消息，减少网络交互次数，提高吞吐量，适用于数据聚合或者日志收集等场景。

8. **过滤消息**：RocketMQ支持基于标签（Tag）或者SQL表达式的消息过滤，允许消费者只接收满足特定条件的消息，提升消息处理的针对性和效率。





**面试官：如何使用Java客户端实现一个简单的消息生产者和消费者？**

在Java中使用RocketMQ实现一个简单的消息生产者和消费者，通常涉及几个关键步骤。下面是一个基本的示例，展示如何设置和使用RocketMQ的客户端进行消息的生产和消费。



**消息生产者**

首先，你需要添加RocketMQ客户端依赖到你的项目中，通常是通过Maven或Gradle。以Maven为例，在pom.xml中添加依赖：

```xml
<dependency>
    <groupId>org.apache.rocketmq</groupId>
    <artifactId>rocketmq-client</artifactId>
    <version>4.9.1</version> 
</dependency>
```

接下来，编写消息生产者代码：

```java

public class SimpleProducer {
    public static void main(String[] args) throws MQClientException, InterruptedException {

        DefaultMQProducer producer = new DefaultMQProducer("ProducerGroupName");

        producer.setNamesrvAddr("yourNamesrvAddr:9876");

        producer.start();

        for (int i = 0; i < 10; i++) {

            Message msg = new Message("TopicTest", "TagA", ("Hello RocketMQ " + i).getBytes(RemotingHelper.DEFAULT_CHARSET));

            SendResult sendResult = producer.send(msg);
            System.out.printf("%s%n", sendResult);
        }


        producer.shutdown();
    }
}
```

**消息消费者**

同样，消费者也需要添加相同的依赖。然后编写消费者代码：

```java

public class SimpleConsumer {
    public static void main(String[] args) throws MQClientException {

        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("ConsumerGroupName");

        consumer.setNamesrvAddr("yourNamesrvAddr:9876");

        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);

        consumer.subscribe("TopicTest", "*");

        consumer.registerMessageListener(new MessageListenerConcurrently() {
            @Override
            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {
                for (MessageExt msg : msgs) {
                    System.out.printf("Received message: %s %n", new String(msg.getBody()));
                }
                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
            }
        });

        consumer.start();

        System.out.println("Consumer Started.");
    }
}
```

在实际应用中，还需要考虑异常处理、日志记录、消息重试策略等高级配置。此外，根据业务需求，还可以选择不同的消费模式（如集群消费、广播消费）和消息模型（如拉取消费、推式消费）。





**面试官：RocketMQ如何保证消息的可靠传输？**

RocketMQ通过多种机制来确保消息的可靠传输，其中包括事务消息、同步发送、异步发送、以及一些底层的存储和复制机制。下面是对这些机制的简要说明：

1. **事务消息**：事务消息机制用于确保消息生产和本地事务操作的一致性。它通过两阶段提交协议实现：预提交阶段，消息先标记为“半消息”，此时消费者不可见；当事务操作成功后，消息被提交为可消费状态；若事务操作失败，则消息被回滚。这一机制确保了消息要么成功提交并被消费，要么在事务失败时被清除，从而保证数据的一致性。

   ![图片](https://mmbiz.qpic.cn/mmbiz_png/B220micXXwOMzicIvuEYKOa6hKsOzVXicttwQ7HtteEo39J3Z7ia5rRiaS5gpbpBib85QVLhsoIovtysW09G8cB4TuXQ/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

2. **同步发送**：同步发送模式下，生产者发送消息后会等待Broker确认消息已存储成功（通常指消息被持久化到磁盘）的响应。如果发送失败或超时，生产者会直接抛出异常或根据配置重试。这种方式牺牲了一定的发送速度，但提供了最高的消息可靠性保障。

3. **异步发送**：异步发送模式允许生产者在发送完消息后立即继续执行其他操作，而消息发送的结果（成功或失败）通过回调函数异步通知生产者。虽然提高了发送速度，但相比同步发送，消息确认的实时性稍差。RocketMQ提供了消息发送重试机制，即使首次发送失败，也可以通过重试提高消息发送的成功率。

4. **同步双写机制**：RocketMQ支持同步双写机制，即消息在内存中持久化的同时，也会同步刷盘到磁盘，确保消息在内存和磁盘上均有备份，即使在极端情况下（如机器断电）也能减少消息丢失的风险。

5. **主从复制**：RocketMQ采用主从架构，每个Broker都有一个主节点和多个从节点。消息在主节点上写入后，会复制到从节点，以确保即使主节点发生故障，消息仍然可以从从节点恢复，进一步增强了消息的持久性和可用性。

6. **消息重试与死信队列**：当消息发送或消费失败时，RocketMQ支持消息重试机制，消息会被重新放入重试队列，根据配置的重试策略尝试再次发送。如果达到最大重试次数仍未成功，消息将被转移到死信队列，供进一步分析或人工处理，避免因持续重试影响系统正常运行。

   ![图片](https://mmbiz.qpic.cn/mmbiz_png/B220micXXwOMzicIvuEYKOa6hKsOzVXicttVtII6g58odvLkfOl4ibeGrrg1PeEbcjNw2U3uJBmQOH4s8IeKFEdLDg/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

综合这些机制，RocketMQ能够在不同的场景和需求下，通过灵活的配置和策略，实现消息的可靠传输，确保数据不丢失，同时兼顾系统的性能和稳定性。





***\*面试官：在RocketMQ中，如何实现消息的顺序消费？遇到分区顺序消息和全局顺序消息时有何不同处理方式？\****

在RocketMQ中，实现消息的顺序消费主要依靠**消息的分区策略以及消费者端的特殊配置。**

RocketMQ顺序消息是一种对消息发送和消费顺序有严格要求的消息。对于一个指定的 Topic，同一消息组的消息按照严格的先进先出（FIFO）原则进行发布和消费，即先发布的消息先消费，后发布的消息后消费，服务端严格按照发送顺序进行存储、消费。同一消息组的消息保证顺序，不同消息组之间的消息顺序不做要求，因此需做到两点，发送的顺序性和消费的顺序性。



**功能原理**

- 发送消息

发送顺序消息发送端要满足以下条件：

同一消息生产组：不同消息组或未设置消息组的消息之间不保证顺序

![图片](https://mmbiz.qpic.cn/mmbiz_png/B220micXXwOMzicIvuEYKOa6hKsOzVXicttTQiaM45ib5rOTtHybHibhzFc2oVsT3EAGx1uEL8aOLGkaZBGJ0KsboLzg/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

如上图所示，消息组1和消息组4的消息混合存储在队列1中，消息队列RocketMQ保证消息组1中的消息G1-M1、G1-M2、G1-M3是按发送顺序存储，且消息组4的消息G4-M1、G4-M2也是按顺序存储，但消息组1和消息组4中的消息不涉及顺序关系。



同一消息生产者：不同生产者之间产生的消息也无法判定其先后顺序，如下图所示：

![图片](https://mmbiz.qpic.cn/mmbiz_png/B220micXXwOMzicIvuEYKOa6hKsOzVXicttqlticC4noOPPzuVRiaTmkrbDOChJglgbLB6Pnudl9y0WERoB9HGpyZNA/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



串行发送：若多线程并行发送，则不同线程间产生的消息将无法判定其先后顺序，如下图所示：

![图片](https://mmbiz.qpic.cn/mmbiz_png/B220micXXwOMzicIvuEYKOa6hKsOzVXictt0IZsYb38t6Ctwd0jacBRe4Q5E6Yzbl9lqle5ia6V7OicaEic2GqV7llTw/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



顺序消费也叫做有序消费，原理是同一个消息队列只允许Consumer中的一个消费线程拉取消费，Consumer中有个消费线程池，多个线程会同时消费消息。在顺序消费的场景下消费线程请求到RocketMQ服务端时会先申请独占锁，获得锁的请求则允许消费。

消息消费成功后，会向RocketMQ服务端提交消费进度，更新消费位点信息，避免下次拉取到已消费的消息，顺序消费中如果消费线程在监听器中进行业务处理时抛出异常，则不会提交消费进度，消费进度会阻塞在当前这条消息，并不会继续消费该队列中的后续消息，从而保证顺序消费。

在顺序消费的场景下，特别需要注意对异常的处理，如果重试也失败，会一直阻塞在当前消息，直到超出最大重试次数，从而在很长一段时间内无法消费后续消息造成队列消息堆积。对于此类问题，处理意见就是合理设计异常处理的代码逻辑和合理调整最大重试次数，避免消息堆积，影响后续消费。



RocketMQ支持两种主要的顺序消息类型：全局顺序消息和分区顺序消息，它们各有不同的实现方式和适用场景。

**分区顺序消息**

1. **实现方式**：

- 分区顺序消息要求消息根据某个Sharding Key（如订单ID）进行分区，相同Sharding Key的消息将被发送到同一个队列（Queue）中。这样，由于RocketMQ保证单个队列内的消息按照先进先出（FIFO）原则进行消费，因此可以保证具有相同Sharding Key的消息在消费时保持顺序。

- 生产者在发送消息时需要指定Sharding Key，RocketMQ根据这个Key将消息分配到对应的队列中。

- 消费者端，需确保同一队列的消息被同一消费者线程顺序处理，RocketMQ通过将队列绑定到消费者组内的特定线程来实现这一点。

  

1. **适用场景**：

- 适用于消息数量大且需要局部顺序保证的场景，比如按用户ID分组的消息处理，确保每个用户的操作顺序正确。



**全局顺序消息**

1. **实现方式**：

- 全局顺序消息要求所有消息保持严格的全局顺序，这意味着所有消息都必须被发送到同一个队列中，因为RocketMQ仅在单个队列级别保证消息的FIFO顺序。

- 为了实现全局顺序，通常会牺牲并行度，因为所有消息只能由一个消费者实例处理。

- 生产者无需显式指定Sharding Key，因为全局顺序消息默认只有一个逻辑上的“分区”。

  

1. **适用场景**：

- 适用于对消息顺序有严格要求，且消息量不是非常大的场景，例如金融交易系统中的交易流水记录，需要严格保证交易的全局时间顺序。

  

**不同处理方式总结**

- 分区顺序消息更适用于大规模消息处理场景，通过合理的分区策略可以在保持部分消息顺序的同时，利用多队列并行消费提升处理效率。
- 全局顺序消息则牺牲了并发性能，以换取严格的消息全局顺序，适用于对顺序要求极高的特定场景，但由于限制在一个队列上，可能会成为性能瓶颈。

在实现顺序消费时，需要根据具体业务需求选择合适的消息类型，并在生产者和消费者两端进行相应的配置。例如，对于分区顺序消息，需要确保Sharding Key的选取能够准确反映消息的顺序关系；对于全局顺序消息，则需考虑单个消费者实例的处理能力和系统的整体吞吐量。





***\*面试官：RocketMQ如何实现高可用性？\****

RocketMQ通过一系列精心设计的机制来确保其高可用性，这些机制包括但不限于：

1. **分布式部署与主从复制**：RocketMQ采用分布式架构，其中每个消息队列可以划分为多个分区，并且这些分区可以部署在不同的Broker节点上。每个Broker节点分为Master和Slave（也称为Primary和Secondary），形成主从结构。主节点负责消息的写入和读取操作，而从节点则实时或异步地复制主节点的数据，以便在主节点发生故障时接管服务，保证消息的连续性和可用性。
2. **多副本机制**：通过配置多从节点，RocketMQ可以进一步增强消息的持久性和可靠性。即使多个节点发生故障，系统仍然能够通过剩余的健康节点继续服务。
3. **自动故障转移**：RocketMQ内置了故障检测和自动切换机制。当检测到主节点不可用时，会自动将从节点提升为主节点，这一过程通常在秒级完成，确保服务的连续性。
4. **NameServer集群**：RocketMQ通过NameServer集群来管理元数据，包括Broker的地址列表、Topic与队列的路由信息等。NameServer集群自身也是高可用的，客户端可以连接到任何一个NameServer获取最新的Broker信息，即使个别NameServer节点失效也不会影响服务。
5. **消息持久化与刷盘策略**：RocketMQ确保消息在内存和磁盘上均有备份，采用同步或异步刷盘策略来平衡性能与可靠性。消息先写入Commit Log，然后根据需要再写入Consume Queue，这种设计既保证了消息的持久性，又优化了读写性能。
6. **消息重试与死信队列**：对于暂时无法正确处理的消息，RocketMQ支持自动重试和死信队列机制，以确保消息最终得到恰当处理，减少数据丢失风险。
7. **流量控制与过载保护**：RocketMQ具备丰富的流量控制策略，可以对生产者和消费者的速率进行限制，防止系统过载，确保消息系统的稳定运行。

总的来说，RocketMQ通过分布式部署、主从复制、自动故障转移、NameServer集群、消息的多层持久化、以及细致的流量控制策略等手段，构建了一个高度可用的消息中间件平台，能够满足各种苛刻的业务场景需求。





***\*面试官：谈谈RocketMQ的Consumer端是如何实现负载均衡的？如果Consumer组内新增或减少成员，RocketMQ如何调整？\****

RocketMQ在Consumer端实现负载均衡主要依赖于其内置的Rebalance（重平衡）机制。这个机制确保了Consumer组内的各个Consumer实例能够均匀地分担Topic下的队列（Queue）消费任务。以下是Consumer端负载均衡的工作原理和动态调整策略：

**负载均衡机制**：

1. **初始化阶段**：当Consumer启动时，它会连接到NameServer集群获取Topic的路由信息，包括所有队列的分布情况。然后，Consumer会根据这些信息决定自己应该订阅哪些队列。
2. **Rebalance触发条件**：Rebalance会在以下情况触发：

- Consumer组内成员变化，如新Consumer加入或已有Consumer离开。
- Topic的队列数发生变化。
- NameServer上的路由信息发生变化。

1. **公平分配策略**：在Rebalance过程中，Consumer组内的所有Consumer实例会协商确定各自应该消费哪些队列。RocketMQ采用一种近似公平的分配策略，尽量使得每个Consumer实例负责相等数量的队列，或者根据队列权重进行分配，以实现负载均衡。
2. **Offset管理**：Consumer还会通过OffsetStore管理自己消费过的消息偏移量，确保在重平衡后能从正确的消息位置开始消费。

**动态调整**：

- **新增Consumer**：当Consumer组内新增成员时，Rebalance会重新分配所有队列，新加入的Consumer将会分得一部分队列进行消费，这有助于减轻原有Consumer的压力，提高整体消费能力。
- **减少Consumer**：如果Consumer组内有成员离开，剩下的Consumer会重新进行负载均衡，原离开Consumer负责的队列会被重新分配给其他存活的Consumer，确保所有队列仍能得到消费，防止消息积压。
- **平滑过渡**：RocketMQ的Rebalance机制设计旨在平滑地进行负载调整，最小化消费中断，尽量避免因成员变动导致的消息重复消费或漏消费。

RocketMQ通过Rebalance机制动态地管理Consumer组内的负载均衡，确保了即使在Consumer数量或队列情况发生变化时，也能快速、高效地重新分配消费任务，维持系统的高可用性和消息处理的高效性。





***\*面试官：RocketMQ支持哪些消息重试策略？在什么情况下会触发消息重试？\****

RocketMQ支持的消息重试策略主要包括：

1. **立即重试**：在非流控错误场景下，如果消息发送失败，RocketMQ会立即进行重试，不设置等待间隔。这意味着消息发送端会迅速尝试再次发送消息，适用于短暂的网络波动或临时性错误。

2. **指数退避重试**：当系统触发流控错误，如消息发送速率超过了Broker设置的阈值，RocketMQ会采取指数退避策略进行延迟重试。这意味着首次重试后，后续的重试间隔会逐渐增加（例如，首次重试可能等待1秒，第二次可能等待2秒，第三次可能等待4秒，以此类推），并且在每次重试之间可能会加入随机抖动以避免所有消费者同时重试造成的雪崩效应。

   

**触发消息重试的情况包括但不限于**：

1. **网络问题**：如网络连接不稳定、短暂中断或延迟，导致消息发送或接收失败。
2. **Broker不可用**：目标Broker节点暂时不可达，可能是由于Broker节点故障、重启或正在进行维护。
3. **消息队列满**：如果消息队列达到了容量上限，新的消息可能无法立即被接受，导致发送失败。
4. **资源限制**：如达到了生产者或消费者的流量限制，Broker可能会出于保护目的拒绝更多的消息处理请求。
5. **消费者处理失败**：消费者在消费消息时如果因为业务逻辑错误、资源不足等原因未能成功消费消息，根据配置可以将消息放回队列进行重试。

需要注意的是，RocketMQ的消息重试机制是有限制的，一般可以通过配置设置最大重试次数。超过最大重试次数后，消息可以根据配置被转移到死信队列，以待进一步分析或人工处理。此外，为了防止消息无限循环重试，开发者需要在业务层面设计幂等性处理逻辑，确保即使消息被多次消费也不会引起业务状态的不一致。





**面试官：RocketMQ是如何存储消息的？**

RocketMQ采用了一种高效且可靠的消息存储机制，主要涉及到以下几个核心组件和机制：

1. **CommitLog**：这是RocketMQ消息存储的核心部分，所有主题（Topic）的消息实体都按顺序写入到这个文件中，确保了写入的高性能和顺序性。CommitLog默认大小为1GB，一旦达到上限就会创建新的文件。这种设计有利于顺序读写，提高I/O效率。
2. **ConsumeQueue**（消费队列）：每个Topic下的每个消息队列都有一个对应的ConsumeQueue文件。ConsumeQueue实质上是一个逻辑上的消息索引，存储了消息在CommitLog中的偏移量、消息长度以及tag的hashcode等信息，使得消费者能够快速定位到CommitLog中的消息实体。这样设计既保证了消息的快速检索，又减少了实际消息内容的访问频率，提升了效率。
3. **IndexFile**（索引文件）：提供了一种通过消息键（Key）或时间范围查询消息的能力。虽然ConsumeQueue已经可以高效地根据队列和时间进行检索，但IndexFile进一步增加了根据消息内容中的特定键进行查询的能力，这对于某些需要根据消息内容进行过滤或查找的场景非常有用。
4. **刷盘机制**：为了确保消息的持久化，RocketMQ提供了同步刷盘和异步刷盘两种模式。同步刷盘在消息写入CommitLog后立即同步到磁盘，保证了数据的强一致性，但性能相对较低；异步刷盘则在消息写入内存后立即返回成功，随后异步地将数据刷入磁盘，提高了吞吐量，但在极端情况下可能有数据丢失的风险。
5. **内存映射**（Memory Mapped File, MMF）：RocketMQ利用内存映射文件技术，将磁盘文件映射到内存空间，使得对文件的访问就像访问内存一样快速，大大提升了读写性能，同时也降低了直接I/O操作的复杂性。
6. **Transient Store Pool**：这是一种内存缓存机制，用于提高消息存储和检索的效率，它作为CommitLog写入前的缓冲区，可以减少磁盘I/O操作的频率，进一步提升性能。

通过上述机制，RocketMQ实现了消息的高效存储与检索，同时保证了消息的持久性和可靠性，适应了高并发、大数据量的场景需求。





**面试官：谈谈有哪些提高RocketMQ吞吐量和降低延迟的方法。**

提高RocketMQ吞吐量和降低延迟是优化消息队列性能的关键目标。以下是一些有效的策略：

**提高吞吐量**

1. **增加Broker节点**：通过水平扩展增加Broker节点，可以分散消息存储和处理的负载，从而提高系统整体的吞吐量。

2. **优化网络配置**：确保RocketMQ集群间及与客户端间的网络通信高效稳定，例如使用高速网络、优化TCP参数、减少网络跳数等。

3. **异步刷盘与消息存储**：配置Broker使用异步刷盘模式，减少I/O等待时间，提高消息写入速度。同时，利用内存映射文件（MMF）技术加快消息的读写速度。

4. **批量处理**：在生产者和消费者端都尽可能使用批量发送或消费消息，减少网络交互次数，提升处理效率。

5. **合理配置队列数**：根据业务需求和硬件资源合理设置Topic的队列数，过多或过少都会影响性能。

6. **优化JVM参数**：针对Broker和客户端的Java应用优化JVM参数，比如合理设置堆内存大小、启用堆外内存、调整垃圾回收策略等。

   

**降低延迟**

1. **异步处理**：无论是生产者还是消费者，都应尽量采用异步处理模式，避免因同步操作阻塞线程，从而减少消息处理延迟。

2. **减少消息序列化与反序列化开销**：选择高效的序列化协议，如protobuf或flatbuffers，减少消息处理过程中的CPU和I/O消耗。

3. **消息预取**：在消费者端开启消息预取功能，提前拉取消息到本地缓存，减少网络往返时间。

4. **优化数据库操作**：对于涉及数据库操作的消息处理，使用批量操作、缓存策略、索引优化等方法减少数据库访问延迟。

5. **合理使用消息过滤**：在Broker端使用Tag过滤而不是在消费者端进行消息筛选，可以减少不必要的消息传输，降低延迟。

6. **优化Rebalance策略**：合理配置Consumer端的重平衡策略，减少因成员变动引起的消费中断和延迟。

   

**综合调优**

- **监控与调优**：持续监控RocketMQ集群的各项指标，如CPU使用率、内存使用情况、磁盘I/O、网络流量等，根据监控数据进行适时调优。
- **资源隔离**：在物理或虚拟机层面，为RocketMQ的各个组件分配独立的资源，避免资源争抢导致的性能下降。
- **利用RocketMQ提供的性能优化工具和建议**：定期查阅官方文档和社区分享，了解最新优化实践和技术更新。





**面试官：在RocketMQ集群中，如何进行消息的过期删除和磁盘空间管理？**

在RocketMQ集群中，**消息的过期删除和磁盘空间管理是通过一系列自动化和可配置的机制来实现的**，以确保集群的高效运行和资源的有效利用。以下是几个关键方面：

**消息过期删除机制**：

1. **队列过期时间**：RocketMQ允许为队列设置过期时间（visibility timeout），如果消息在队列中等待的时间超过了这个设置值，消息会被标记为过期并从队列中删除。这个机制适用于那些未被消费的消息。
2. **消费超时确认**：消费者拉取消息后，如果在消费者侧设定的超时时间内未确认（ACK）消息，这些消息也会被视为过期，并可能被重新投递或根据配置处理。
3. **定时清理**：RocketMQ有一个定时任务负责检查并删除过期消息。此机制确保了即使消息未被显式确认过期，也能按照预定的策略清理。

**磁盘空间管理**：

1. **文件过期删除**：RocketMQ会自动清理已过期的消息文件。过期判定基于文件的存储时间，以及配置的清理规则。默认情况下，清理任务会在每天的凌晨4点执行，但也可以根据实际情况调整。
2. **磁盘占用率监控**：RocketMQ监控磁盘空间使用情况，当达到不同级别的磁盘占用警戒线时，会触发不同的响应策略：

- 当磁盘占用率达到75%，且有文件过期，会开始清理过期文件。
- 达到85%，开始按照规则清理文件，不限于过期文件。
- 若占用率达到90%，Broker将拒绝新的消息写入，以防止磁盘空间耗尽导致服务不可用。

3. **清理策略**：RocketMQ会优先清理最老的文件，以释放空间。清理操作考虑到了消息的顺序性和完整性，避免破坏消息队列的逻辑结构。

**手动管理与配置优化**：

- 管理员可以通过调整RocketMQ的配置文件，如修改清理时间点、警戒线比例等，来适应不同的应用场景和资源约束。
- 对于特殊需求，如需立即释放空间，可能需要结合RocketMQ提供的API或管理界面进行更细致的操作，比如手动触发过期消息的清理。





**面试官：解释事务消息的实现原理，并描述其在RocketMQ中的应用场景。**

事务消息是RocketMQ提供的一种高级消息类型，它用来解决分布式事务中的一致性问题，特别是在微服务架构中，多个服务间需要保持数据一致性时尤为重要。事务消息的实现原理大致可以分为两阶段提交（2PC）的变体，具体步骤如下：

![图片](https://mmbiz.qpic.cn/mmbiz_png/B220micXXwOMzicIvuEYKOa6hKsOzVXicttDLFTAO3ro6cBvKofibP1o7AVhJGxpdjsuaPt6Oo6r7cEicwlh8oguIww/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**实现原理**：

**1. 半消息（Prepared Message）阶段**：

- **发送阶段**：生产者首先向RocketMQ发送一条半消息（也称为Prepare消息）。半消息不会被立即投递给消费者，而是处于待确认状态。
- **本地事务执行**：生产者在发送半消息后，立即执行本地事务逻辑。此时，本地事务的执行结果未知。

**2. 提交或回滚阶段：**

- **提交**：如果本地事务执行成功，生产者需要向RocketMQ发送一个“提交”指令，RocketMQ会将半消息标记为可投递，消费者随后可以消费到这条消息。
- **回滚**：如果本地事务执行失败，生产者发送一个“回滚”指令，RocketMQ会直接删除这条半消息，消费者不会看到这条消息。

**3. 消息检查与补偿机制：**

- RocketMQ还包含一个检查机制，如果在一定时间内没有收到生产者的“提交”或“回滚”指令，会根据配置重试或按照之前约定的策略（通常是回滚）处理半消息。



**应用场景**：

1. **分布式事务协调**：在涉及多个服务的分布式事务中，如订单系统、库存系统、支付系统需要同时更新数据时，事务消息可以确保所有服务要么全部完成更新，要么全部不更新，保证数据一致性。
2. **资金账户转账**：当需要在不同账户之间转移资金时，可以使用事务消息来确保转账操作要么在源账户扣款并目标账户加款成功，要么两者都不发生，避免资金错账。
3. **订单与库存同步**：电商场景中，用户下单后需要减少商品库存并生成订单记录。通过事务消息，可以确保库存减少操作与订单创建操作一致，防止超卖现象。
4. **消息驱动的微服务**：在基于事件驱动的微服务架构中，事务消息可以用于确保事件的可靠传递和处理，比如用户注册后触发邮件通知、积分增加等多个下游服务的处理，确保各服务间的数据一致性。

通过事务消息，RocketMQ为分布式系统提供了一种实现跨服务事务一致性的解决方案，降低了开发复杂度，提高了系统的可靠性。





**面试官：什么是RocketMQ中的死信队列？它是如何产生的？如何处理死信消息？**

RocketMQ中的死信队列（Dead-Letter Queue，简称DLQ）是一种特殊的队列，用于存储那些在正常消费流程中无法被正确处理的消息，即死信消息（Dead-Letter Message）。

这些消息通常是因为消费失败且超过了预设的最大重试次数而被转移到死信队列中。RocketMQ的死信队列机制帮助系统隔离有问题的消息，避免它们无限循环重试，影响正常消息的处理流程。



**如何产生死信队列消息**：

1. **消费失败重试**：当消息被发送到消费者后，如果消费失败，RocketMQ会自动进行消息重试。一旦消息重试达到预设的最大次数（默认是16次），并且每次重试之间的延迟策略也已用尽（默认策略下，重试间隔逐渐增大），该消息会被视为无法正常消费，进而转入死信队列。
2. **延时消息异常**：如果消息设置了延时级别，但在消息应该被消费时仍无法正确处理，也可能被转入死信队列，特别是当延时级别设置为负数时。



**处理死信消息的方式**：

1. **监控与手动检查**：首先，可以通过RocketMQ提供的管理界面或者API来监控死信队列，定期检查死信队列中的消息，了解失败原因。
2. **死信消息重定向**：可以配置系统或编写专门的消费者程序来监听死信队列，对这些消息进行特殊处理，比如重新尝试消费、记录日志、报警、或者进行人工干预。
3. **死信消息修复与重发**：对于某些因配置错误、网络瞬断等暂时性问题导致的死信，可以修复相关问题后，将消息重新发送到正常的业务队列中进行消费。
4. **死信消息废弃**：确认某些消息确实无法正常处理，可以选择废弃这些消息，避免持续占用资源。
5. **数据分析与优化**：分析死信产生的原因，可以帮助优化消费逻辑、调整重试策略或改善系统设计，从而减少未来死信的产生。

通过上述方法，开发者可以有效地管理RocketMQ中的死信，确保系统的稳定性和消息处理的完整性。





***\*面试官：RocketMQ支持哪些消息过滤方式？\****

RocketMQ支持以下几种消息过滤方式：

1. **Tag过滤**：这是最基本也是最常用的消息过滤方式。生产者在发送消息时可以为消息指定一个或多个Tag，消费者在订阅时通过指定Tag来过滤消息，仅接收匹配指定Tag的消息。如果一个消息有多个Tag，可以用||分隔。这种方式简单高效，可以在Broker端实现过滤，减少不必要的网络传输。
2. **SQL92过滤**：RocketMQ支持使用SQL92标准的简单表达式进行消息过滤。消费者可以在订阅时提供一个SQL表达式，RocketMQ会根据这个表达式的内容在Broker端过滤消息。这允许更复杂的过滤逻辑，如基于消息属性的过滤。需要注意的是，要启用SQL过滤功能，需要在Broker的配置文件中设置enablePropertyFilter=true。
3. **自定义属性过滤**：除了Tag，RocketMQ还支持利用消息的自定义属性进行过滤。消费者可以在订阅时指定自定义属性的条件，Broker根据这些条件进行消息筛选。这也是在Broker端完成的，可以有效减轻Consumer的负担。
4. **表达式过滤与类模式过滤**：虽然具体细节不如Tag和SQL过滤方式那么明确，RocketMQ也提供了表达式过滤和类模式过滤的机制，允许根据更灵活的规则来筛选消息。

通过这些过滤机制，RocketMQ能够满足不同场景下消息的精确分发需求，确保消费者仅接收到其关心的消息，提高了消息传递的效率和系统的灵活性。





**面试官：如何监控RocketMQ集群的健康状态？有哪些常用的监控指标？**

监控RocketMQ集群的健康状态对于确保消息系统稳定运行至关重要。常用的监控指标和方法包括：

**监控工具与方法**

1. **RocketMQ Console**：这是官方提供的Web监控界面，可以直观地查看Broker、Topic、Consumer Group等的运行状态，包括但不限于队列数、消息堆积量、消费者分布等信息。通过配置application.properties文件中的namesrvAddr，与NameServer集群建立连接。
2. **第三方监控系统集成**：如Prometheus+Grafana、Zabbix、Nagios等，通过接入RocketMQ提供的监控接口或自定义脚本，收集各项指标数据，进行可视化展示和告警配置。
3. **日志监控**：分析RocketMQ的日志文件，如Broker和Consumer的日志，可以发现潜在的问题和异常。



**常用监控指标**

1. **Broker状态**：包括Broker是否在线、主备状态切换情况、磁盘使用率、内存使用率等。
2. **消息堆积量**：特别是未确认消息的数量，是衡量系统处理能力的重要指标，堆积过多可能表明消费端存在问题。
3. **消费进度**：每个Consumer Group消费特定Topic的进度，用于评估消费效率和是否存在滞后。
4. **TPS（Transactions Per Second）和QPS（Queries Per Second）**：分别代表每秒事务处理量和查询处理量，是衡量系统吞吐量的关键指标。
5. **延时**：消息从生产到消费的平均延迟时间，影响实时性要求高的应用。
6. **网络IO**：包括入站和出站的流量，以及网络连接的稳定性，影响消息传输效率。
7. **JVM性能指标**：如GC频率、堆内存使用率、线程状态等，对于运行在Java虚拟机上的RocketMQ Broker和客户端尤为重要。
8. **磁盘读写速度**：Broker的磁盘I/O性能直接影响消息存储和检索的速度。
9. **Broker线程池状态**：监控线程池的工作队列长度、活跃线程数，可以反映Broker处理消息的能力和负载情况。
10. **系统负载和CPU使用率**：过高或波动大的CPU使用率可能意味着系统资源紧张。

通过持续监控这些关键指标，并结合合理的告警策略，可以及时发现并解决RocketMQ集群中的问题，保障消息系统的稳定性和可靠性。





***\*面试官：假设你遇到RocketMQ消息丢失的情况，你会从哪些方面进行排查？\****

遇到RocketMQ消息丢失的情况，可以从以下几个方面进行排查：

1. **生产者端检查**：

- **网络问题**：检查生产者与RocketMQ Broker之间的网络连接是否稳定，是否存在网络抖动或丢包现象。
- **发送异常**：查看生产者日志，确认消息发送是否成功，是否有发送失败的错误日志，如超时、连接失败等。
- **配置问题**：确认生产者配置是否正确，比如消息发送模式（同步/异步）、重试策略、超时时间等。
- **消息过期**：确认发送的消息是否设置了过期时间，以及消息是否因过期而被Broker自动删除。



2. **RocketMQ Broker端检查**：

- **Broker状态**：检查Broker是否正常运行，是否存在异常重启情况。
- **存储问题**：检查Broker磁盘状态，是否有磁盘损坏或空间不足导致的消息丢失。
- **刷盘模式**：确认Broker的刷盘模式（SYNC_FLUSH或ASYNC_FLUSH），同步刷盘可以减少消息丢失风险，但需权衡性能。
- **配置与日志**：查看Broker配置文件（如broker.properties），确认消息存储、清理策略等配置是否合理；分析Broker日志，寻找可能的错误信息或异常提示。

3. **消费者端检查**：

- **消费确认机制**：确认消费者是否正确实现了消息消费的ACK机制，是否存在未消费完成就错误发送ACK的情况。
- **消费逻辑**：检查消费者代码逻辑，是否有异常抛出导致消费中断，或者消费过程中的资源争抢问题。
- **消费位点**：分析消费者的消费位点（offset）是否正确，是否存在位点跳跃导致的消息未被消费。



4. **RocketMQ Dashboard监控**：

- 利用RocketMQ-Dashboard或类似工具，查看消息发送、消费的趋势图，检查是否有明显的消息下降趋势或消费停滞。
- 查找特定消息ID或按时间范围搜索消息，确认消息是否真的未到达预期的队列或已被消费。



5. **集群配置与架构**：

- **NameServer状态**：确保所有NameServer节点均运行正常，客户端能够连接到至少一个NameServer。
- **集群健康**：检查集群各节点间的负载均衡情况，是否存在单点压力过大导致的消息处理问题。





***\*面试官：设计一个场景，说明如何利用RocketMQ实现系统解耦和异步处理。\****

**场景描述**：电商平台的订单系统与库存系统解耦及异步处理

在典型的电商平台中，用户下单后，系统需要执行一系列操作，其中包括订单创建、库存扣减、支付处理、物流通知等。如果不采用消息队列，这些操作可能会在一个事务中紧密耦合，导致系统复杂度增加，响应时间延长，且任何一个环节的故障都可能影响整个流程。



**利用RocketMQ实现解耦和异步处理的方案如下**：

1. **解耦**：

- 当用户下单后，订单系统不再直接调用库存系统进行扣减操作，而是向RocketMQ发送一条“扣减库存”的消息。
- 库存系统作为一个独立的服务，订阅了“扣减库存”的消息队列。当有新消息到达时，库存系统自动处理库存扣减逻辑。
- 即使库存系统出现短暂故障，订单系统依然可以正常工作，因为它只需将消息放入RocketMQ，无需等待库存系统响应，从而实现了订单系统与库存系统的解耦。

1. **异步处理**：

- 订单系统发送完消息后，无需等待库存系统处理完成，即可快速响应用户，告知订单创建成功，提升了用户体验。
- RocketMQ负责消息的存储与转发，即使在高并发场景下，也能通过消息队列缓存请求，实现削峰填谷，避免库存系统因瞬间大量请求而崩溃。
- 库存系统可以根据自身的处理能力，异步地从消息队列中拉取消息并逐步处理库存扣减，实现了处理过程的异步化。



**效果**：

- **系统解耦**：订单系统和库存系统之间通过RocketMQ消息传递，减少了直接调用的依赖，各自可以独立扩展和维护，提高了系统的灵活性和可维护性。
- **异步处理**：订单处理流程不再受制于库存扣减的耗时，提升了整体系统的响应速度和吞吐量，尤其是在高峰期，能够更好地应对流量洪峰。

通过此场景，可以看出RocketMQ不仅能够帮助实现系统间的解耦，还能促进异步处理模式的实施，从而增强系统的可扩展性、稳定性和性能。





**面试官：在高并发场景下，如何确保RocketMQ的消息不被重复消费？**

在高并发场景下，确保RocketMQ的消息不被重复消费，可以采取以下策略：

1. **幂等性设计**：确保消费逻辑具有幂等性，即多次消费同一条消息产生的结果与消费一次相同。例如，对于增加库存、更新用户积分等操作，可以通过在业务逻辑层检查操作的唯一标识（如交易ID、消息ID）来判断该操作是否已经执行过，避免重复处理。
2. **消费确认机制**：利用RocketMQ的消息消费确认机制（ACK）。消费者在正确处理完消息后，需向RocketMQ发送确认消息（ACK），RocketMQ才会将该消息从队列中移除。如果消费过程中发生异常，应确保ACK不被发送，RocketMQ会在一定时间后重新投递该消息。
3. **消息唯一标识**：为每条消息分配一个全局唯一的ID（如Message ID），并在消费者侧维护一个已消费消息ID的记录（如使用Redis、数据库等持久化存储）。每次消费前，检查消息ID是否已存在于记录中，若存在则直接忽略，避免重复消费。
4. **限流与重试策略**：合理设置消费端的消费速率，避免因消费过快导致处理不过来而频繁触发重试机制。同时，针对失败的消息，可以自定义更智能的重试策略，如指数退避重试，而非无脑重试，减少因重试导致的重复消费可能性。
5. **消息去重窗口**：在消费逻辑中设定一个合理的去重时间窗口，比如利用消息ID与消费时间戳的组合来判断是否属于重复消息。如果在短时间内收到了相同ID的消息，可以视为重复消息并忽略。
6. **优化网络与Broker稳定性**：减少网络波动和Broker故障导致的消息重传。通过优化网络环境，提高Broker的稳定性和可用性，减少因网络不稳定或Broker重启而导致的消息重复发送。



[面试官：说说看你知道的常见限流算法有哪些？它们的优缺点分别是什么？如何基于用户身份限流？](http://mp.weixin.qq.com/s?__biz=MzUxMjczODMyMA==&mid=2247485826&idx=1&sn=bba2c932c1b0d7e170375760692e2b54&chksm=f95e9cfdce2915eb0b57440ea344d72462252e4b6c0c6ea6ae1c06058f76bb10adf32e773342&scene=21#wechat_redirect)

[Redis面试题：什么是Redis的大key和热key，它们会造成什么问题，如何解决？](https://mp.weixin.qq.com/s?__biz=MzUxMjczODMyMA==&mid=2247485761&idx=1&sn=2c02dc7d4817cdd98d887f690bc64768&scene=21#wechat_redirect)

[阿里二面：在高并发场景下如何保证消息只被消费一次？](https://mp.weixin.qq.com/s?__biz=MzUxMjczODMyMA==&mid=2247485294&idx=1&sn=a7a2c910e4e69d60cbac282fd24b54fe&scene=21#wechat_redirect)

[面试题：说说看进程、线程和协程的区别是什么？协程能够并行吗？Goroutine和Coroutine的区别是什么？](https://mp.weixin.qq.com/s?__biz=MzUxMjczODMyMA==&mid=2247485237&idx=1&sn=b4a9d76e2e7d52aead973cf8bae1f06c&scene=21#wechat_redirect)

[面试题：什么是缓存击穿、缓存穿透和缓存雪崩？它们分别会带来什么危害？该如何解决和预防？](http://mp.weixin.qq.com/s?__biz=MzUxMjczODMyMA==&mid=2247485797&idx=1&sn=7ccf13aea967081d5fff69a85cd44cd5&chksm=f95e9c1ace29150c2d5be64d8a5f0df2f16644104545b3a874583cdeca7bbef60c0242045059&scene=21#wechat_redirect)